package com.github.slavetto.parser.models;

import com.github.slavetto.utils.StringUtils;

import java.util.ArrayList;

/*
 * Created with â™¥
 */
public class CardTemplate {

    private static final String IMAGE_PATH_REGEX       = "(<img[^(src)]+src=\")([^\"]+)\"";
    private static final String IMAGE_PATH_REPLACEMENT = "$1anki-images/$2\"";

    private String frontTemplate;
    private String rearTemplate;

    /**
     * Position of the template in the template array. This is used by the cards to identify which of the templates of
     * the {@link CardModel} generated it.
     */
    private int ord;

    CardTemplate(String frontTemplate, String rearTemplate, int ord) {
        this.frontTemplate = frontTemplate;
        this.rearTemplate = rearTemplate;
        this.ord = ord;
    }

    public String getFrontTemplate() {
        return frontTemplate;
    }

    public String getRearTemplate() {
        return rearTemplate;
    }

    /**
     * @return position of the template in the template array. This is used by the cards to identify which of the
     * templates of the {@link CardModel} generated it.
     */
    public int getOrd() {
        return ord;
    }

    /**
     * Applies the current template of the front of the card to the fields contained in the card and updates the
     * images paths if any
     * @param cardReference the card to pull the fields from
     * @param fields the array containing, in order, the fields
     * @return the HTML generated by the substitution
     */
    String renderFront(CardReference cardReference, ArrayList<String> fields) {
        return updateImagesPath(substituteFields(fields, cardReference.getFields(), frontTemplate));
    }

    /**
     * Updates the paths of all the images that this template links to. After the export all the images will be in a
     * particular folder; however, in anki they are not.
     * @param template the template to search for images in
     */
    private String updateImagesPath(String template) {
        return template.replaceAll(IMAGE_PATH_REGEX, IMAGE_PATH_REPLACEMENT);
    }

    /**
     * Replaces all the fields placeholders in the template with their actual value.
     * @param fieldNames the names of the fields as reported in the template
     * @param fieldValues the values of the fields; it must follow the same order of <code>fieldName</code>
     * @param template the template where we'll search for fields
     * @return the generated template, with all fields substituted
     */
    private String substituteFields(ArrayList<String> fieldNames, String[] fieldValues, String template) {
        String html = template;
        for (int i = 0; i < fieldNames.size(); i++) {
            String name  = fieldNames.get(i);
            String value = fieldValues[i];

            html = html.replace(StringUtils.curlyfy(name), value);
        }

        return html;
    }

    /**
     * Applies the current template of the rear of the card to the fields contained in the card and updates the
     * images paths if any
     * @param cardReference the card to pull the fields from
     * @return the HTML generated by the substitution
     */
    String renderRear(CardReference cardReference, ArrayList<String> fields) {
        String generatedRear = updateImagesPath(substituteFields(fields, cardReference.getFields(), rearTemplate));

        //In the rear of the cards it's possible to use the "{{FrontSide}}" placeholder. This placeholder stands for the
        //front of the card.
        return generatedRear.replace("{{FrontSide}}", renderFront(cardReference, fields));
    }

}
